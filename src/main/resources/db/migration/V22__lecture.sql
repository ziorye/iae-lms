CREATE TABLE `lecture`
(
    `id`                      bigint unsigned NOT NULL AUTO_INCREMENT,
    `title`                   varchar(255) NOT NULL,
    `title_translation`       varchar(255)          DEFAULT NULL,
    `slug`                    varchar(255)          DEFAULT NULL,
    `content`                 text,
    `video`                   varchar(255)          DEFAULT NULL,
    `video_id`                varchar(255)          DEFAULT NULL,
    `duration`                int unsigned NOT NULL DEFAULT '0',
    `description`             text,
    `description_translation` text,
    `sort_order`              int          NOT NULL DEFAULT '0',
    `published`            tinyint(1) NOT NULL DEFAULT '1',
    `free`                 tinyint(1) NOT NULL DEFAULT '0',
    `requires_login`          tinyint(1) NOT NULL DEFAULT '0',
    `cover`                   varchar(255)          DEFAULT NULL,
    `section_id`              bigint unsigned NOT NULL,
    `collection_id`           bigint unsigned NOT NULL,
    `created_at`              timestamp NULL DEFAULT NULL,
    `updated_at`              timestamp NULL DEFAULT NULL,
    `deleted_at`              timestamp NULL DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `lectures_slug_unique` (`slug`)
);


# --- data ---
INSERT INTO `lecture` (`title`, `title_translation`, `slug`, `content`, `video`, `video_id`, `duration`, `description`, `description_translation`, `sort_order`, `published`, `free`, `requires_login`, `cover`, `section_id`, `collection_id`, `created_at`, `updated_at`, `deleted_at`)
VALUES
	('安装 Docker', NULL, 'docker-install__doc', '开始学习之前，需要先安装并启动 Docker\r\n\r\n## 安装 Docker\r\n\r\n- [在 Windows 上安装 Docker](https://docs.docker.com/docker-for-windows/install/)\r\n- [在 Mac 上安装 Docker](https://docs.docker.com/docker-for-mac/install/)\r\n- [在 Ubuntu 上安装 Docker](https://docs.docker.com/engine/install/ubuntu/)\r\n- [在 CentOS 上安装 Docker](https://docs.docker.com/engine/install/centos/)\r\n- 更多支持的系统，查看[官方文档](https://docs.docker.com/engine/install/)\r\n\r\n## 启动 Docker\r\n\r\n本文以 MacOS 为例：\r\n\r\n1. 双击已经安装好的 Docker 应用图标\r\n   ![docker desktop](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/mlmLZ1628304059_docker_desktop1617268347.png)\r\n2. Docker 应用启动成功之后，可以在顶部状态栏的右上角位置看到它的图标\r\n   ![docker desktop status bar](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/r6Lsc1628304059_docker_desktop_status_bar1617268347.png)\r\n3. 点击顶部状态栏上的 Docker 图标，可以进一步查看和操作 Docker\r\n   ![docker desktop more actions](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/b6wey1628304059_docker_desktop_more_actions1617268347.png)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 1, 1, now(), NULL, NULL),
	('运行第一个 Docker 容器', NULL, 'docker-getting-started__doc', '## 执行 `docker run` 命令\r\n\r\n打开命令行工具，执行以下命令\r\n\r\n```shell\r\ndocker run -d -p 8000:80 docker/getting-started\r\n```\r\n\r\n等这条命令执行成功之后，docker 已经为我们启动了一个新的容器，在容器的 80 端口上运行着一个 `getting-started`  Web 服务，并将本机上的 8000 端口映射到容器中的 80 端口。\r\n\r\n因此，现在可以直接在本机访问 [http://localhost:8000](http://localhost:8080) 即可访问到容器中 80 端口上启动的 `getting-started`  Web 服务了。\r\n\r\n至此，我们已经启动了第一个 Docker 容器。先学会如何使用、先观察到效果，是循序渐进学习的重点；至于什么是容器，什么是镜像将在后续慢慢展开介绍。\r\n\r\n> 部分参数说明：\r\n> \r\n> - `docker/getting-started` - 使用的镜像名称\r\n> - `-p 8000:80` - 将本机上的 8000 端口映射到容器中的 80 端口\r\n> - `-d` - 让容器保持在后台运行，返回容器 ID\r\n>   \r\n>   备注：类似 -d 和 -p 这种单个字符的参数可以进行合并，所以上一条命令可以简写为：\r\n>   `docker run -dp 8000:80 docker/getting-started`\r\n\r\n## Docker Dashboard\r\n\r\n刚才提到的容器和镜像，在哪里可以看到它们？\r\n\r\n方法 1：通过执行 Docker 提供的 cli 命令查看\r\n\r\n- `docker container ls` - 查看正在运行的容器\r\n- `docker images` - 查看有哪些镜像\r\n\r\n方法 2：通过 Docker 提供的可视化界面 Docker Dashboard 查看\r\n\r\n![Docker Dashboard menu](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/teMmo1628305176_Docker_Dashboard_menu1617268364.png)\r\n\r\nDocker Dashboard 不止可以快速查看机器上运行的容器和拥有的镜像。还可以快速访问容器日志、轻松管理容器的生命周期（启动、停止，删除等...）更多功能可以参考官方文档 [Mac 版本](https://docs.docker.com/docker-for-mac/dashboard/) 或 [Windows 版本](https://docs.docker.com/docker-for-windows/dashboard/)。\r\n如果现在你已经打开了 Docker Dashboard，将会看到本教程的 getting-started 容器正在运行中。容器名称默认是随机创建的（如下图显示的 `agitated_chaplygin`）你自己看到到很可跟下图显示的不一致：\r\n\r\n![Tutorial container running in Docker Dashboard](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/Jy90L1628305176_Tutorial_container_running_in_Docker_Dashboard1617268365.png)\r\n\r\n当然，也可以自己指定容器的名称，只需在运行容器时增加 `--name` 参数，主动指定容器名称即可，如：\r\n`docker run -d -p 8000:80 --name container-name docker/getting-started`\r\n\r\n## 什么是容器?\r\n\r\n简而言之，容器只是在你计算机上的另一个进程，但是这个进程与主机上的所有其他进程是相互隔离的。这种隔离利用了 Linux 上已经存在很长时间的功能：[内核名称空间和 cgroup](https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504)。Docker 致力于使这些功能更容易实现、更便于使用。\r\n\r\n## 什么是镜像?\r\n\r\n容器运行时使用的是隔离的文件系统。这个自定义的文件系统就是由 `镜像` 提供。由于镜像包含容器的文件系统，因此它必须包含运行应用程序所需的所有内容：所有依赖项、配置、脚本、二进制文件等。该镜像还包含容器的其他配置，例如环境变量、要运行的默认命令以及其他元数据。后续将会更深入的研究镜像，诸如镜像的分层，构建镜像的最佳实践等主题。\r\n\r\n> 原始资料：[Get Started](https://docs.docker.com/get-started/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 1, 1, now(), NULL, NULL),
	('创建自己的 Docker 镜像', NULL, 'our-docker-image__doc', '本教程将通过一个最简单的、使用 JavaScript 开发的待办事项管理 Web 应用程序贯穿始终，下文简称为：`todo-app`。这个应用程序的代码已经写好并提供了源码的下载地址，所以如果你不太熟悉 JavaScript 和 Node.js 也完全没有任何关系，依旧可以很轻松的学习本教程，因为我们的学习重点是 Docker，所以放心的继续往下看吧。\r\n\r\n此时，你只是想开发一个最小可行产品（MVP）来证明自己的想法，展示它的工作原理和功能,暂时无需考虑其他复杂因素。\r\n\r\n![Todo List Manager Screenshot](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/6HKyC1628305251_Todo_List_Manager_Screenshot1617268644.png)\r\n\r\n## 获取 `todo-app` 源码\r\n\r\n在运行 `todo-app` 之前，需要将它的源代码下载到自己的计算机上。在实际工作中开发的项目，通常是去公司的代码仓库克隆。但是，针对本教程，我们创建好了一个包含应用程序源码的 ZIP 压缩文件。\r\n\r\n1. [点击这里下载](https://default-sz.oss-cn-shenzhen.aliyuncs.com/docker/app.zip) 并解压，解压之后默认文件夹名称是 `app`， 非必要的情况下，不要修改文件夹名称，因为保存名称一致，有利于后续文档的说明。\r\n2. 使用你喜欢的编辑器打开，下图使用的是 [Visual Studio Code](https://code.visualstudio.com/) 编辑器作为演示，你可以使用任何自己喜欢的编辑器打开它，打开之后会看到 `package.json` 文件、 `yarn.lock` 文件和两个子目录 `src` 和 `spec`。\r\n   ![Screenshot of Visual Studio Code opened with the app loaded](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/HkQ7M1628305251_Screenshot_of_Visual_Studio_Code_opened_with_the_app_loaded1617268644.png)\r\n\r\n## 为 `todo-app` 创建镜像\r\n\r\n需要一个 `Dockerfile` 文件来为我们的应用程序创建 Docker 容器镜像。`Dockerfile` 文件就是一个文本文件，文本的内容描述着如何一步步构建出我们需要的镜像。\r\n\r\n1. 创建一个名为 `Dockerfile` 的文件，与 `package.json` 文件同一层级，内容如下：\r\n   \r\n   ```\r\n   FROM node:12-alpine\r\n   WORKDIR /app\r\n   COPY . .\r\n   RUN yarn install --production\r\n   CMD [\"node\", \"src/index.js\"]\r\n   ```\r\n   \r\n   这个 `Dockerfile` 的每一行都代表着告诉 Docker 镜像构造器每一步该怎么做：\r\n   \r\n   - 我们的镜像要基于 `node: 12-alpine` 镜像\r\n   - 指定镜像的工作目录是 `/app`\r\n   - 接着将主机上当前项目目录下的所有内容（即：`app` 目录下的所有内容）复制到镜像中的当前工作目录（即：`/app` 目录下）\r\n   - 接着执行 `yarn install --production` 命令为 `todo-app` 安装依赖\r\n   - 最后一步通过 `CMD` 指定镜像被启动时默认要执行的命令，即通过 node 真正启动我们的 `todo-app` Web 应用程序。\r\n   \r\n   > 备注：确保刚刚创建的 `Dockerfile` 文件没有文件扩展名，有些编辑器可能会自动附加文件扩展名。\r\n2. 打开命令行并进入到 `Dockerfile` 文件所在的 `app` 目录，执行如下命令：\r\n   \r\n   ```\r\n   docker build -t todo-app .\r\n   ```\r\n   \r\n   这条命令就是使用刚刚创建的 `Dockerfile` 文件构建出一个新的容器镜像。从这条命令的输出结果中，你应该已经注意到有很多步骤，对应着 `Dockerfile` 文件的每一行。\r\n   `-t` 标志代表为我们的镜像打标签，可以简单地理解成为镜像取一个易于理解的名称。由于我们将镜像命名为 `todo-app` 因此可以在运行容器时引用这个镜像名称。docker build 命令最后的 `.` 代表告诉 Docker 在当前目录下查找 `Dockerfile` 文件。\r\n\r\n## 用刚创建的镜像启动容器\r\n\r\n现在已经为我们的 `todo-app` 应用创建了一个名字为 `todo-app` 的 Docker 镜像，看看如何使用它：\r\n\r\n1. 使用 `docker run` 命令启动一个新容器，并指定使用我们刚刚创建的镜像：\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 todo-app\r\n   ```\r\n   \r\n   还记得 `-d` 和 `-p` 标记吗?\r\n   `-d` - 让容器保持在后台运行；\r\n   `-p 3000:3000` - 将容器中的 3000 端口映射到本机的 3000 端口。\r\n   因此，通过这条命令，我们使用自己创建的 `todo-app` 镜像启动了一个新容器。在容器中的 3000 端口上启动着我们自己的 `todo-app` Web 应用程序，并将容器中的 3000 端口映射到本机的 3000 端口。\r\n2. 在本机上访问 [http://localhost:3000](http://localhost:3000/) 就可以看到我们自己的应用了：\r\n   ![Empty Todo List](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/ZC3xz1628305251_Empty_Todo_List1617268645.png)\r\n\r\n此时，一个由我们自己亲手创建的 `todo-app` 应用已经运行在 Docker 上了。\r\n\r\n## 回顾\r\n\r\n在这一小节中，我们学习了有关构建容器镜像的基础知识，并创建了一个 `Dockerfile` 来完成此操作。构建镜像完成之后，我们使用该镜像启动了一个新容器并看到了正在运行的、我们自己的 `todo-app` 应用。\r\n\r\n接下来，将对我们的应用程序进行修改。在此过程中，进一步学习 Docker 的其他知识。\r\n\r\n> 原始资料：[Our Application](https://docs.docker.com/get-started/02_our_app/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 2, 1, now(), NULL, NULL),
	('更新应用并重新构建 Docker 镜像', NULL, 'updating-our-dockder-image__doc', '现在要对我们的应用做一点点小更新：\r\n\r\n## 修改源码\r\n\r\n1. 修改 `src/static/js/app.js` 文件的第 56 行：将 `No items yet! Add one above!` 修改为 `You have no todo items yet! Add one above!`\r\n2. 输入之前使用过的命令，重新构建镜像\r\n   \r\n   ```\r\n   docker build -t todo-app .\r\n   ```\r\n3. 使用新版本镜像运行容器\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 todo-app\r\n   ```\r\n   \r\n   你可能会看到如下错误信息：\r\n\r\n```\r\ndocker: Error response from daemon: driver failed ...... Bind for 0.0.0.0:3000 failed: port is already allocated.\r\n```\r\n\r\n之所以出现这个问题，是因为本机的 3000 端口已经被我们之前启动的容器占用了。要解决此问题，我们可以删除旧的容器。\r\n\r\n## 删除容器\r\n\r\n要删除容器，首先需要将其停止，然后将其删除。有两种方法可以停止并删除容器：\r\n\r\n### 使用 CLI 命令删除容器\r\n\r\n1. 使用 `docker ps` 命令获取容器的 ID\r\n   ```\r\n   docker ps\r\n   ```\r\n2. 使用 `docker stop` 命令停止容器\r\n   ```\r\n   # 将下方的 <the-container-id> 替换成你想停止的容器 ID\r\n   docker stop <the-container-id>\r\n   ```\r\n3. 容器停止后，可以使用 `docker rm` 命令删除它\r\n   ```\r\n   # 将下方的 <the-container-id> 替换成你想删除的容器 ID\r\n   docker rm <the-container-id>\r\n   ```\r\n\r\n> 备注：\r\n> 可以通过增加 `-f` 标志来合并上面的第 2、3 步，使用一条命令停止并删除容器。如：`docker rm -f <the-container-id>`\r\n\r\n### 使用 Docker Dashboard 删除容器\r\n\r\n通过 Docker Dashboard 可以很方便的删除容器，比通过 CLI 命令查找容器 ID 之后再将其删除要容易得多。\r\n\r\n1. 打开 Docker Dashboard 之后，将鼠标悬停在应用程序容器上，在右侧会看到一系列可以对容器进行操作的按钮\r\n2. 点击垃圾桶图标删除容器\r\n3. 在弹出的确认窗口中真正删除它\r\n   ![Docker Dashboard - removing a container](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/JycIY1628305342_Docker_Dashboard_-_removing_a_container1617268738.png)\r\n\r\n> 备注：在 Docker Dashboard 中我们还看到了另一个非绿色图标显示的容器，这个容器是没有启动成功的，就是上一次执行命令出现报错的时候留下来的，我们也可以用同样的操作删除掉它。\r\n> ![Docker Dashboard - removing another container](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/jPMjx1628305342_Docker_Dashboard_-_removing_another_container1617268739.png)\r\n\r\n### 再一次使用新版本镜像运行容器\r\n\r\n1. 运行新容器\r\n   ```\r\n   docker run -dp 3000:3000 todo-app\r\n   ```\r\n2. 再一次访问 [http://localhost:3000](http://localhost:3000/) 将会看到我们更新之后的效果了\r\n\r\n![Updated application with updated empty text](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/0H45P1628305342_Updated_application_with_updated_empty_text1617268739.png)\r\n\r\n## 回顾\r\n\r\n在本节中，我们修改了源代码，同时重新执行了构建镜像命令。\r\n\r\n虽然我们成功构建了新版本镜像，但是你可能已经注意到了两个小问题：\r\n\r\n* 镜像更新之前添加的所有代办事项，全部都消失了，数据没有被保存起来\r\n* 本次修改只是一个非常简单的文字更新，但是重新构建镜像的过程中，`Dockerfile` 文件列出的每一个步骤都需要重新执行一遍。肯定还有更高效的方式让容器感知代码的变化，而不必重新执行所有步骤。\r\n\r\n之后的章节将会解决这两个问题，在开始解决这些问题之前，让我们先快速了解一下如何把我们构建好的镜像分享给其他人使用。\r\n\r\n> 原始资料：[Updating our Application](https://docs.docker.com/get-started/03_updating_app/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 2, 1, now(), NULL, NULL),
	('分享自己创建的 Docker 镜像', NULL, 'sharing-our-docker-image__doc', '现在我们已经构建了自己的镜像，是时候把它分享给其他人使用了！要分享 Docker 镜像，需要使用 Docker registry，默认的 registry 是 Docker Hub\r\n\r\n> 备注：本文档不对 `registry` 和 `repository` 进行翻译，出现它们的地方都保留原始英文。\r\n> Registry 和 Repository 的区别\r\n> \r\n> - [Registry 的官方解释](https://docs.docker.com/registry/)：The Registry is a stateless, highly scalable server side application that stores and lets you distribute Docker images. The Registry is open-source, under the permissive [Apache license](https://en.wikipedia.org/wiki/Apache_License).  Registry 是一个无状态、高可用的服务端程序，用于存储和分发 Docker 镜像。同时它是一个基于 Apache license 的开源程序。正是由于它是开源的，所有除了 Docker 官方的 registry （即：Docker Hub）还有很多第三代的 registry，甚至你还可以自己部署一个 registry。\r\n> - Repository 是 registry 内部真正保存具体每个镜像内容的地方。\r\n\r\n## 创建 Repository\r\n\r\n本文以 Docker 默认的 registry，也就是 Docker Hub 为例进行说明。要推送镜像，首先需要在 Docker Hub 上创建一个 Repository。\r\n\r\n1. 访问 [Docker Hub](https://hub.docker.com/) 并登录\r\n2. 点击 **Create Repository** 按钮\r\n3. Repository 名称使用 `todo-app`，将 **Visibility** 设置为 `Public`\r\n4. 点击 **Create** 按钮\r\n\r\n在页面的右侧会看到一个名为 **Docker commands** 的部分。列出了一个示例命令，参考示例命令将自己的镜像推送到仓库。\r\n\r\n![Docker command with push example](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/lidjE1628305471_Docker_command_with_push_example1617268791.png)\r\n\r\n## 推送自己的镜像\r\n\r\n1. 执行 `docker login -u YOUR-USER-NAME` 命令，登录到 Docker Hub\r\n2. 使用 `docker tag` 命令为 `todo-app` 镜像指定一个新名称。确保用您的 Docker ID 替换 `YOUR-USER-NAME`。\r\n   \r\n   ```\r\n   # 用你的 Docker ID 替换 `YOUR-USER-NAME`\r\n   docker tag todo-app YOUR-USER-NAME/todo-app\r\n   ```\r\n3. 使用 `docker push` 推送镜像。如果不指定标签，则 Docker 将默认使用名为 `latest` 的标签\r\n   \r\n   ```\r\n   # 用你的 Docker ID 替换 `YOUR-USER-NAME`\r\n   docker push YOUR-USER-NAME/todo-app\r\n   ```\r\n\r\n## 运行刚刚推送到仓库的镜像\r\n\r\n现在，我们已经将镜像推送到 registry 中，如果其他人要使用我们分享的镜像，就可以通过执行以下命令来使用了：\r\n\r\n```\r\n# 用你的 Docker ID 替换 `YOUR-USER-NAME`\r\ndocker run -dp 3000:3000 YOUR-USER-NAME/todo-app\r\n```\r\n\r\n## 回顾\r\n\r\n在本节中，学习了如何通过将镜像推送到 Docker Hub 这个默认的 registry 来分享我们自己的镜像。\r\n\r\n现在，让我们回过头来看看上一节 `回顾` 中提到的其中一个的小问题：重新启动容器时，会丢失所有待办事项列表数据。下一节将介绍如何解决这个问题。\r\n\r\n> 原始资料：[Sharing Our Application](https://docs.docker.com/get-started/04_sharing_app/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 2, 1, now(), NULL, NULL),
	('使用 Docker 命名卷 named volume 持久化数据', NULL, 'docker-named-volume__doc', '到目前为止，使用我们自己创建的镜像启动的容器，每次重启都会清除之前的待办事项数据。为什么会这样？让我们深入研究容器的工作方式。\r\n\r\n## 容器的文件系统\r\n\r\n在之前的章节介绍过，容器运行时使用的是隔离的文件系统，而这个特殊的文件系统就是由 `镜像` 提供的。在一个容器的文件系统上创建/更新/删除文件，都不会影响到另一个容器，即使它们使用的是同一个镜像。\r\n\r\n### 动手验证\r\n\r\n为了验证这一点，我们将启动两个容器，并在其中一个容器中创建一个文件，看看这个文件会不会出现在使用了同一个镜像启动的另一个容器中。\r\n\r\n1. 启动一个 `Ubuntu` 容器，在该容器中创建一个名为 `/data.txt` 的文件，文件内容是 1 到 10000 之间的随机数：\r\n   \r\n   ```\r\n   docker run -d Ubuntu bash -c \"shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null\"\r\n   ```\r\n   \r\n   容器启动之后，开启一个 bash shell 并执行两个命令，`&&` 之前的第一个命令是选择一个 1 到 10000 的随机数，将其写入到 `/ data.txt` 文件中。`&&` 之后的第二个命令只是监视文件以便让容器保持持续运行的状态。\r\n2. 通过 `docker exec` 命令查看容器中 `/data.txt` 文件的内容。\r\n   \r\n   ```\r\n   # 执行上一条 `docker run ...` 命令时输出到控制台的内容就是 <container-id>\r\n   # 也可以通过执行 `docker ps` 获取到 <container-id>\r\n   docker exec <container-id> cat /data.txt\r\n   ```\r\n   \r\n   你应该看到 `/data.txt` 文件的内容了\r\n3. 现在，让我们使用同一个镜像，启动另一个 `ubuntu` 容器，执行以下命令查看新容器的根目录下是否有 `data.txt` 文件：\r\n   \r\n   ```\r\n   docker run -it Ubuntu ls /\r\n   ```\r\n   \r\n   显然并没有看到 `data.txt` 文件，因为它仅被写入第一个容器的暂存空间中，不同容器直接彼此是隔离的。\r\n4. 验证了之后，就可以使用 Docker Desktop 或者使用 `docker rm -f <container-id>` 命令删除之前启动的第一个容器了。\r\n\r\n## 容器的卷 `Volume`\r\n\r\n> 备注：Volume 一般翻译成：卷。但是本文尽量不去翻译这种专有名词，保持英文原文。\r\n\r\n在之前的实验中，我们看到每个容器每次启动都从镜像的定义中重新开始创建容器的文件系统。尽管容器可以创建、更新和删除文件，但是当容器被删除或者重新启动时，之前创建或修改的文件都将丢失。使用 `Volume`，可以改变目前的现状。\r\n\r\n[Volumes](https://docs.docker.com/storage/volumes/) 提供将容器的特定文件系统路径连接回主机的功能。如果容器中的一个目录被挂载，那么这个目录的修改同样能够在主机上被看到。如果在重新启动容器时挂载了相同的目录，就能够看到相同的文件了。\r\n\r\n> 备注：这里说的 `主机` 或者 `本机` 指的是运行 Docker 引擎的这台机器，也就是我们的 Mac、Windows 或者 Linux 机器。\r\n\r\n`volumes` 有两种类型，先从开始 **named volumes** 介绍。同样的，这里的 `named volumes` 一般翻译成 `命名卷`，但是在后续的章节中，我们也尽量不去翻译它。\r\n\r\n## 保存我们的待办事项数据\r\n\r\n默认情况下，我们的 `todo-app` 应用程序使用的是 [SQLite 数据库](https://www.sqlite.org/index.html) 将数据存储在 `/etc/todos/todo.db` 文件中。如果你不熟悉 SQLite，不用担心！它跟 MySQL 类似都属于关系型数据库，但是 `SQLite` 更简单一些，它将所有数据都存储在一个文件中。虽然这对于大型应用程序不是最佳选择，但对于小型演示型应用却很适合。稍后我们会讨论如何将它切换到其他数据库引擎，比如 MySQL 数据库。\r\n\r\n由于我们要用数据库是单个文件，因此我们可以将这个文件保存在主机上，然后创建一个 `volume`，将主机上的这个文件与容器中的某个位置关联在一起，这样就可以解决重启或者在新启动容器出现的数据丢失问题了。\r\n\r\n如前所述，我们将使用 **named volume** 来实现这个功能，可以将 **named volume** 视为简单的数据桶。 Docker 维护主机上的物理位置，你只需要记住 `volume` 的名称即可。每次使用该 `volume` 时，Docker 将确保提供正确的数据。\r\n\r\n1. 使用 `docker volume create` 命令创建 `volume`\r\n   ```\r\n   # 也可以不用主动创建，当执行下方第 3 步的时候，Docker 会自动检测我们指定的 volume 是否存在，如果不存在会自动帮我们创建\r\n   docker volume create todo-db\r\n   ```\r\n2. 通过 Docker Dashboard 或者使用 `docker rm -f <container-id>` 命令停止并删除正在运行中的 `todo-app` 应用程序容器\r\n3. 再次启动容器, 但是这次要添加 `-v` 标志以指定要挂载的 `volume`。我们将使用 `named volume` 并将其挂载到容器上的 `/etc/todos` 路径下，这个 `named volume` 将会感知在这个路径下创建的所有文件。\r\n   ```\r\n   docker run -dp 3000:3000 -v todo-db:/etc/todos todo-app\r\n   ```\r\n4. 容器启动后，访问我们的应用程序并添加一些待办事项\r\n   ![Items added to todo list](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/W8fmo1628305546_Items_added_to_todo_list1617269932.png)\r\n5. 参考第 2 步，再一次删除正在运行的容器\r\n6. 参考第 3 步，再一次启动容器\r\n7. 访问我们的应用，验证是否还能看到之前添加的待办事项\r\n\r\n## 深入看一看 Volume\r\n\r\n很多人经常问：“当我使用 `named volume` 时，Docker 实际上在哪里存储数据？”\r\n如果你想知道答案，可以使用 `docker volume inspect ...` 命令查看 volume 的详细信息。\r\n\r\n```\r\ndocker volume inspect todo-db\r\n\r\n[\r\n    [\r\n        \"CreatedAt\" => \"2021-01-12T03:35:55Z\",\r\n        \"Driver\" => \"local\",\r\n        \"Labels\" => null,\r\n        \"Mountpoint\" => \"/var/lib/docker/volumes/todo-db/_data\",\r\n        \"Name\" => \"todo-db\",\r\n        \"Options\" => null,\r\n        \"Scope\" => \"local\"\r\n    ]\r\n]\r\n```\r\n\r\n`Mountpoint` 的值就是主机上存储数据的实际位置。需要注意的是，在大多数计算机上，需要具有 root 访问权限的用户才能在主机上访问此目录。\r\n\r\n## 回顾\r\n\r\n这一节，我们学会了如何为容器持久化存储数据了。\r\n\r\n下一节，将介绍如何使用另外一种 `volume` 类型：`bind mounts` 及时让容器感知到主机上源代码的变动。\r\n\r\n> 原始资料：[Persisting our DB](https://docs.docker.com/get-started/05_persisting_data/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 3, 1, now(), NULL, NULL),
	('使用 bind mounts 快速搭建本地开发环境', NULL, 'docker-bind-mounts__doc', '在上一节中，我们讨论并使用了 **named volume** 将数据持久保存在数据库中。如果我们只想简单的存储数据，那么 **named volume** 就够用了，因为我们不必关心数据的存储位置。\r\n\r\n这一节，将在介绍另外一种 `volume` 类型，即：`bind mounts`\r\n使用 **bind mounts** 我们可以控制主机上的准确挂载点。虽然也可以用它来保存数据，但是通常是用它来向容器提供额外数据。比如：我们可以使用 **bind mounts** 将主机上的源代码挂载到容器中，以便容器可以及时感知源代码的变更。\r\n\r\n对于基于 Node.js 的应用程序，[nodemon]（https://npmjs.com/package/nodemon）是监视文件更改然后重新启动应用程序的好工具。大多数其他语言和框架都有类似的工具。\r\n\r\n## 两种不同 Volume 类型的比较\r\n\r\n`named volumes` 和 `bind mounts` 是 Docker 引擎内置的两种主要 `Volume` 类型。也可以使用其他类型的 Volume 驱动程序来支持其他使用场景，如 [SFTP](https://github.com/vieux/docker-volume-sshfs)、[Ceph](https://ceph.com/geen-categorie/getting-started-with-the-docker-rbd-volume-plugin/)、[NetApp](https://netappdvp.readthedocs.io/en/stable/)、[S3](https://github.com/elementar/docker-s3-volume) 等...\r\n\r\n|                                              | Named Volumes             | Bind Mounts                   |\r\n| ---------------------------------------------- | --------------------------- | ------------------------------- |\r\n| 在主机上的位置                               | 由 Docker 自动选择            | 由你自己决定                  |\r\n| 挂载示例 (使用 `-v` 标记)               | my-volume:/usr/local/data | /path/to/data:/usr/local/data |\r\n| 使用容器内容填充新 volume | 是                       | 否                            |\r\n| 支持 Volume 驱动程序                    | 是                       | 否                            |\r\n\r\n## 启动一个开发模式的容器\r\n\r\n为了运行一个支持开发工作流程的容器，我们将执行以下操作：\r\n\r\n* 将我们的源代码挂载到容器中\r\n* 安装所有依赖项，包括 `dev` 依赖项\r\n* 启动 `nodemon` 来监听文件变化\r\n\r\n让我们开始吧：\r\n\r\n1. 删除之前启动的 `todo-app` 容器\r\n2. 执行以下命令：\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 \\\r\n       -w /app \\\r\n       -v \"$(pwd):/app\" \\\r\n       node:12-alpine \\\r\n       sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n   \r\n   如果使用的是 PowerShell，执行下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 `\r\n       -w /app `\r\n       -v \"$(pwd):/app\" `\r\n       node:12-alpine `\r\n       sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n   \r\n   * `-dp 3000:3000` - 之前遇到过了，表示让容器保持在后台运行并做好端口映射\r\n   * `-w /app` - 设置 \"working directory\" - 工作目录\r\n   * `-v \"$(pwd):/app\"` - `bind mount` 主机上的当前目录挂载到容器上的 `/app` 目录\r\n   * `node:12-alpine` - 使用的镜像\r\n   * `sh -c \"yarn install && yarn run dev\"` - 在容器中执行两条命令。由于 alpine 没有 bash，所以通过 sh 执行这两条命令，第一条：`yarn install` 安装我们程序用到的依赖；第二条：`yarn run dev` 启动服务。如果我们查看 `package.json` 文件就会发现 `dev` 脚本正是使用能够监听文件变化并自动重启服务的 `nodemon`（一旦主机上的源码有变化，它能及时监听到，并自动重启 todo-app 服务）\r\n3. 由于上一条命令会在容器中执行安装依赖的操作，在不同的网络环境下的执行时间可能快也可能慢，因此需要等待一会才能访问我们的服务。可以通过 `docker logs` 命令查看容器日志，先执行 `docker image ls` 查看容器 ID，再执行 `docker logs -f <container-id>` 命令，如果看到日志输出了 `Listening on port 3000` 就代表我们的程序已经启动成功。\r\n   \r\n   ```\r\n   docker logs -f <container-id>\r\n   \r\n   yarn install ...\r\n   [1/4] Resolving packages...\r\n   [2/4] Fetching packages...\r\n   ......\r\n   [3/4] Linking dependencies...\r\n   [4/4] Building fresh packages...\r\n   Done in 93.42s.\r\n   ......\r\n   $ nodemon src/index.js\r\n   [nodemon] 1.19.2\r\n   [nodemon] to restart at any time, enter `rs`\r\n   [nodemon] watching dir(s): *.*\r\n   [nodemon] starting `node src/index.js`\r\n   Using SQLite database at /etc/todos/todo.db\r\n   Listening on port 3000\r\n   ```\r\n   \r\n   看完日志后，按 `Ctrl + C` 退出。\r\n4. 现在，让我们来再一次修改源代码。将 `src/static/js/app.js` 文件第 109 行的 \"Add Item\" 改成 \"Add\"\r\n5. 只需刷新应用的首页，几乎就能立即在浏览器中看到更改。容器内部自动重新启动 Node 服务器可能需要花费几秒钟的时间，因此，如果访问页面出现错误，可以稍等几秒钟后再试。\r\n   ![Screenshot of updated label for Add button](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/kiT3b1628305588_Screenshot_of_updated_label_for_Add_button1617270009.png)\r\n6. 至此，你可以随时在本机对应用程序源码进行任何更改。完成后，停止容器并使用 `docker build -t todo-app .` 重新构建新镜像。\r\n   在本地开发模式下，使用 `bind mounts` 非常普遍。它的优点是使得本地开发机器不需要安装所有构建工具和环境。只需一条 docker run 命令，开发环境就准备就绪了。\r\n\r\n## 回顾\r\n\r\n本节我们学习了如何通过 `bind mounts` 快速搭建本地开发环境。\r\n\r\n下一节我们准备将数据库从 SQLite 改成更适合生产环境使用的 MySQL。那么问题来了，我们该如何运行 MySQL? 如何让不同容器之间彼此通信？下节再详细说明。\r\n\r\n> 原始资料：[Using Bind Mounts](https://docs.docker.com/get-started/06_bind_mounts/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 3, 1, now(), NULL, NULL),
	('Docker 多容器应用 Multi-Container Apps', NULL, 'docker-multi-container-apps__doc', '到目前为止，我们一直在使用单个容器应用程序。但是，我们现在想将 MySQL 添加到应用程序架构中。那么，问题来了：MySQL 将在哪里运行？是将它安装在同一容器中还是在另外的单独容器中运行？\r\n一般来说，**一个容器应该只做一件事。** 原因：\r\n\r\n* 虽然你可以在开发阶段使用本地数据库，但是很可能要在生产环境中使用云数据库。所以，将数据库与应用程序运行在同一个容器中不太合适。\r\n* 一般情况下，一个容器应该仅启动一个进程，如果在同一个容器中运行多个进程会增加容器启动/关闭/服务运行情况监听的复杂性。\r\n\r\n还有其他更多原因。因此，我们会新启动一个容器运行 MySQL 服务，结构如下：\r\n\r\n![Todo App connected to MySQL container](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/OZc3z1628305632_Todo_App_connected_to_MySQL_container1617270064.png)\r\n\r\n## 容器 Networking\r\n\r\n默认情况下，容器是独立运行的，并且对同一台主机上的其他进程或容器一无所知。So, how do we allow one container to talk to another? The answer is **networking**. Now, you don\'t have to be a network engineer (hooray!). Simply remember this rule...那么，我们如何允许一个容器与另一个容器对话？答案是通过 **networking** - 网络。你不必具备网络工程师的知识，只需要记住一个最简单的规则就够用了：`如果两个容器在同一个网络中，它们就可以相互通信。否则，就不行`\r\n\r\n## 启动 MySQL\r\n\r\n接着就让我们将 `todo-app` 与 `MySQL` 这两个容器放在同一个网络中：\r\n\r\n1. 创建网络\r\n   \r\n   ```\r\n   docker network create todo-app\r\n   ```\r\n2. 启动 MySQL 容器并为它指定网络。我们还设置了一些环境变量的值，MySQL 将使用这些变量来初始化数据库，它支持的所有环境变量可以查看 [MySQL 镜像的说明](https://hub.docker.com/_/mysql/)\r\n   \r\n   ```\r\n   docker run -d \\\r\n       --network todo-app --network-alias MySQL \\\r\n       -v todo-mysql-data:/var/lib/mysql \\\r\n       -e MYSQL_ROOT_PASSWORD=secret \\\r\n       -e MYSQL_DATABASE=todos \\\r\n       mysql:5.7\r\n   ```\r\n   \r\n   如果使用的是 PowerShell，执行下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n   \r\n   ```\r\n   docker run -d `\r\n       --network todo-app --network-alias MySQL `\r\n       -v todo-mysql-data:/var/lib/mysql `\r\n       -e MYSQL_ROOT_PASSWORD=secret `\r\n       -e MYSQL_DATABASE=todos `\r\n       mysql:5.7\r\n   ```\r\n   \r\n   你应该看到了，我们增加了 `--network-alias` 标记，稍后再讨论它。\r\n   \r\n   > 备注：\r\n   > 这条命令还通过 `-v` 标记使用了名字为 `todo-mysql-data` 的 `volume` 并将它挂载到 `/var/lib/mysql` 路径下，也就是 MySQL 真正存储数据的地方。虽然我们没有先执行 `docker volume create` 命令提前创建 `volume` 但是 Docker 识别到我们要用 `named volume`，并自动为我们创建了一个。\r\n3. 为了确认数据库是否已经启动成功，可以使用以下命令连接到数据库容器，验证是否能连接成功。\r\n   \r\n   ```\r\n   docker exec -it <mysql-container-id> MySQL -p\r\n   ```\r\n   \r\n   出现输入密码的界面时，输入上一条命令指定的 **MYSQL_ROOT_PASSWORD** 环境变量的值 `secret`\r\n   成功进入 MySQL 之后，执行以下命令列出所有数据库\r\n   \r\n   ```\r\n   mysql> SHOW DATABASES;\r\n   ```\r\n   \r\n   你应该能看到如下所示的输出：\r\n   \r\n   ```\r\n   +--------------------+\r\n   | Database           |\r\n   +--------------------+\r\n   | information_schema |\r\n   | MySQL              |\r\n   | performance_schema |\r\n   | sys                |\r\n   | todos              |\r\n   +--------------------+\r\n   5 rows in set (0.00 sec)\r\n   ```\r\n\r\n## 连接到 MySQL\r\n\r\nMySQL 已启动成功，让我们使用它吧！但是，问题是...怎么用？如果我们在同一个网络上运行另一个容器，如何找到该容器？\r\n\r\n为了弄清楚这一点，我们将使用 [nicolaka/netshoot](https://github.com/nicolaka/netshoot) 容器, 它内置*大量*可用于对网络问题进行故障排除或调试的工具。\r\n\r\n1. 使用 nicolaka/netshoot 镜像启动一个新容器。确保将它连接到同一个网络上\r\n   \r\n   ```\r\n   docker run -it --network todo-app nicolaka/netshoot\r\n   ```\r\n2. 在容器内部，我们将使用 `dig` 命令，这是一个有用的 DNS 工具。我们将查找主机名 `mysql` 的 IP 地址\r\n   \r\n   ```\r\n   dig MySQL\r\n   ```\r\n   \r\n   将会看到类似如下的输出...\r\n   \r\n   ```\r\n   ; <<>> DiG 9.14.1 <<>> MySQL\r\n   ;; global options: +cmd\r\n   ;; Got answer:\r\n   ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 32162\r\n   ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\r\n   \r\n   ;; QUESTION SECTION:\r\n   ;mysql.             IN  A\r\n   \r\n   ;; ANSWER SECTION:\r\n   mysql.          600 IN  A   172.18.0.2\r\n   \r\n   ;; Query time: 0 msec\r\n   ;; SERVER: 127.0.0.11#53(127.0.0.11)\r\n   ;; WHEN: Wed Jan 13 05:21:49 UTC 2021\r\n   ;; MSG SIZE  rcvd: 44\r\n   ```\r\n   \r\n   在 \"ANSWER SECTION\" 应答部分，会看到 `mysql` 的 A 记录，解析为 172.18.0.2（你看到的 IP 地址很可能跟我不一样）。虽然 `mysql` 通常不是有效的主机名，但 Docker 能够将其解析为具有该网络别名的容器的 IP 地址（还记得我们之前在启动 MySQL 容器时使用的 `--network-alias` 标志吗？它的作用就是为这个容器主机取一个别名）。这意味着...我们的应用程序仅需连接到名为 `mysql` 的主机，就能跟数据库对话了，就是这么简单！\r\n\r\n## 使用 MySQL 运行我们的应用\r\n\r\n我们的 todo-app 应用程序支持一些环境变量的设置，以指定 MySQL 连接设置。它们是：\r\n\r\n* `MYSQL_HOST` - MySQL 服务器的主机名\r\n* `MYSQL_USER` - 用于连接的用户名\r\n* `MYSQL_PASSWORD` - 用于连接的密码\r\n* `MYSQL_DB` - 连接后要使用的数据库\r\n\r\n> 重要提醒：\r\n> 直接通过在命令行中设置环境变量的做法，在本地开发模式下没什么问题，但是 `强烈反对` 在生产环境中使用。Docker 前安全负责人 Diogo Monica，[撰写了一篇精彩的博客文章](https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/) 详细解释了反对的原因。\r\n> 一种更安全的机制是使用 `container orchestration framework` 提供的安全支持。在大多数情况下，这些密码会作为文件挂载到正在运行的容器中。你会看到许多应用程序（包括 MySQL 镜像和 我们自己的 todo-app 应用程序）也支持带有 `_FILE` 后缀的环境变量以指向包含真正环境变量的文件。 例如，设置 `MYSQL_PASSWORD_FILE` 变量，这个变量指向的文件内容将被作为 `MYSQL_PASSWORD` 的值，即，真正的连接密码。Docker 默认不支持这种环境变量，你的应用需要自己清楚如何寻找变量并获取文件内容。\r\n\r\n在解释了所有这些内容之后，让我们利用刚刚掌握的知识启动一个新容器：\r\n\r\n1. 我们将指定 `todo-app` 应用程序需要用到的几个环境变量，并将容器连接到我们的应用程序网络上\r\n   \r\n   ```\r\n   # 确保在本机的 app 目录下执行以下命令\r\n   docker run -dp 3000:3000 \\\r\n     -w /app \\\r\n     -v \"$(pwd):/app\" \\\r\n     --network todo-app \\\r\n     -e MYSQL_HOST=mysql \\\r\n     -e MYSQL_USER=root \\\r\n     -e MYSQL_PASSWORD=secret \\\r\n     -e MYSQL_DB=todos \\\r\n     node:12-alpine \\\r\n     sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n   \r\n   如果使用的是 PowerShell，执行下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n   \r\n   ```\r\n   docker run -dp 3000:3000 `\r\n     -w /app `\r\n     -v \"$(pwd):/app\" `\r\n     --network todo-app `\r\n     -e MYSQL_HOST=mysql `\r\n     -e MYSQL_USER=root `\r\n     -e MYSQL_PASSWORD=secret `\r\n     -e MYSQL_DB=todos `\r\n     node:12-alpine `\r\n     sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n2. 通过查看容器的日志（`docker logs <container-id>`），应该能看到类似 `Connected to MySQL db at host mysql` 的日志输出，代表我们的应用程序现在就是使用 MySQL 数据库来保存数据了。\r\n   \r\n   ```\r\n   # 省略之前的日志消息 ...\r\n   $ nodemon src/index.js\r\n   [nodemon] 1.19.2\r\n   [nodemon] to restart at any time, enter `rs`\r\n   [nodemon] watching dir(s): *.*\r\n   [nodemon] starting `node src/index.js`\r\n   Connected to MySQL db at host MySQL\r\n   Listening on port 3000\r\n   ```\r\n3. 访问我们的应用程序，然后添加一些待办事项\r\n4. 连接到 MySQL 数据库并证明这些待办事项已被写入到 MySQL 数据库。记住，密码是 **secret**\r\n   \r\n   ```\r\n   docker exec -it <mysql-container-id> MySQL -p todos\r\n   ```\r\n   \r\n   进入 MySQL 之后执行以下命令：\r\n   \r\n   ```\r\n   mysql> select * from todo_items;\r\n   +--------------------------------------+--------------------+-----------+\r\n   | id                                   | name               | completed |\r\n   +--------------------------------------+--------------------+-----------+\r\n   | c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! |         0 |\r\n   | 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome!        |         0 |\r\n   +--------------------------------------+--------------------+-----------+\r\n   ```\r\n   \r\n   很显然，你的表数据跟我的不一样，因为它保存的是你刚刚输入的待办事项。但是，你应该能看到它们被存储在这里了！\r\n\r\n如果你现在打开 Docker Dashboard 将会看到有两个正在运行的应用程序容器，其中一个是 MySQL 容器，另一个是我们的 todo-app 应用。但是，它们现在看起来好像没有任何关系。\r\n\r\n![Docker Dashboard showing two ungrouped app containers](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/NQEE81628305632_Docker_Dashboard_showing_two_ungrouped_app_containers1617270065.png)\r\n\r\n## 回顾\r\n\r\n至此，我们有了一个应用程序，它现在将其数据存储在单独运行的数据库容器中。\r\n\r\n但是，要启动整个程序有点麻烦，我们必须创建一个网络，启动多个容器，指定所有环境变量，映射端口等等！这样复杂的步骤既不利于自己使用也不方便分享给其他人使用。\r\n\r\n在下一节中，我们将讨论 Docker Compose。借助 Docker Compose 可以以一种更简单的方式分享我们的应用，并允许其他人只使用一个简单的命令就可以将它们运行起来！\r\n\r\n> 原始资料：[Multi-Container Applications](https://docs.docker.com/get-started/07_multi_container/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 3, 1, now(), NULL, NULL),
	('使用 Docker Compose', NULL, 'using-docker-compose__doc', '[Docker Compose](https://docs.docker.com/compose/) 是一款旨在帮助定义和共享多容器应用程序的工具。通过 Compose，我们可以创建一个 YAML 文件来定义需要使用的所有服务，并且只需要一个命令就可以启动或停止所有服务。\r\n\r\n使用 Compose 的最大优点是你只需在一个文件中定义自己的应用程序栈（即应用程序需要用到的所有服务），然后把这个 YAML 文件放在项目的根目录下，与源码一起受版本控制。其他人只需 clone 你的项目源码之后就可以快速启动服务。实际上，在 GitHub 或 GitLab 上已经有很多项目正在这样做。\r\n\r\n我们也来为 todo 应用创建一个 YAML 文件吧。\r\n\r\n## 安装 Docker Compose\r\n\r\n如果你使用的是 Windows 或者 Mac 桌面操作系统，在安装 Docker Desktop 之后就已经内置了 Docker Compose。如果你使用的是 Linux 系统，可以参照 [此处的说明](https://docs.docker.com/compose/install/) 安装 Docker Compose\r\n\r\n安装完成之后，可以执行以下命令查看它的版本信息：\r\n\r\n```\r\ndocker-compose version\r\n```\r\n\r\n## 创建我们的 Compose 文件\r\n\r\n1. 在 `todo-app` 项目的根目录下，创建一个名为 `docker-compose.yml` 的文件\r\n2. 在 `docker-compose.yml` 文件的第一行定义 schema version。在大多数情况下，最好使用最新的受支持 schema version。你可以查看 [Compose file reference](https://docs.docker.com/compose/compose-file/) 以获得最新的 schema version 和兼容性列表。\r\n   ```\r\n   version: \"3.7\"\r\n   ```\r\n3. 接下来，我们将定义 `todo-app` 应用程序依赖的一系列服务（或容器）列表。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n   ```\r\n\r\n接着，我们开始将之前通过命令行执行的命令，翻译成 compose 文件支持的格式。\r\n\r\n## 定义 `todo-app` 应用服务\r\n\r\n回顾一下之前使用过的命令：\r\n\r\n```\r\ndocker run -dp 3000:3000 \\\r\n  -w /app \\\r\n  -v \"$(pwd):/app\" \\\r\n  --network todo-app \\\r\n  -e MYSQL_HOST=mysql \\\r\n  -e MYSQL_USER=root \\\r\n  -e MYSQL_PASSWORD=secret \\\r\n  -e MYSQL_DB=todos \\\r\n  node:12-alpine \\\r\n  sh -c \"yarn install && yarn run dev\"\r\n```\r\n\r\n如果使用的是 PowerShell，之前使用的是下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n\r\n```\r\ndocker run -dp 3000:3000 `\r\n  -w /app `\r\n  -v \"$(pwd):/app\" `\r\n  --network todo-app `\r\n  -e MYSQL_HOST=mysql `\r\n  -e MYSQL_USER=root `\r\n  -e MYSQL_PASSWORD=secret `\r\n  -e MYSQL_DB=todos `\r\n  node:12-alpine `\r\n  sh -c \"yarn install && yarn run dev\"\r\n```\r\n\r\n1. 首先，定义 `todo-app` 应用服务名称和使用的镜像，可以为它取任何名称，这里简单取成同名 `todo-app`。该名称将自动作为网络的别名，在后续定义 MySQL 服务时将很有用。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n   ```\r\n2. 接着我们把容器启动之后要执行的命令写在靠近定义 `image` 的地方，尽管不一定按照这样的顺序书写，但是通常都这样做。类似下面这样：\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n   ```\r\n3. 接着定义端口映射\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n       ports:\r\n         - 3000:3000\r\n   ```\r\n4. 再来将 `-w /app` **工作目录** 和 `-v \"$(pwd):/app\"` **volume** 通过 `working_dir` 和 `volumes` 这两个属性来定义。\r\n   在 Docker Compose 配置文件中定义 volume 的一个优点是我们可以使用基于 `docker-compose.yml` 文件所在目录的相对路径。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n       ports:\r\n         - 3000:3000\r\n       working_dir: /app\r\n       volumes:\r\n         - ./:/app\r\n   ```\r\n5. 最后，通过 `environment` 定义 `todo-app` 需要使用到的环境变量。\r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       image: node:12-alpine\r\n       command: sh -c \"yarn install && yarn run dev\"\r\n       ports:\r\n         - 3000:3000\r\n       working_dir: /app\r\n       volumes:\r\n         - ./:/app\r\n       environment:\r\n         MYSQL_HOST: MySQL\r\n         MYSQL_USER: root\r\n         MYSQL_PASSWORD: secret\r\n         MYSQL_DB: todos\r\n   ```\r\n\r\n### 定义 MySQL 服务\r\n\r\n现在，是时候定义 MySQL 服务了。同样先回顾之前启动 MySQL 容器时使用的命令：\r\n\r\n```\r\ndocker run -d \\\r\n  --network todo-app --network-alias MySQL \\\r\n  -v todo-mysql-data:/var/lib/mysql \\\r\n  -e MYSQL_ROOT_PASSWORD=secret \\\r\n  -e MYSQL_DATABASE=todos \\\r\n  mysql:5.7\r\n```\r\n\r\n如果使用的是 PowerShell，之前使用的是下面这条命令（只是 `多行输入` 的分隔符不一样而已）\r\n\r\n```\r\ndocker run -d `\r\n  --network todo-app --network-alias MySQL `\r\n  -v todo-mysql-data:/var/lib/mysql `\r\n  -e MYSQL_ROOT_PASSWORD=secret `\r\n  -e MYSQL_DATABASE=todos `\r\n  mysql:5.7\r\n```\r\n\r\n1. 先定义一个新服务并将它命名为 `mysql`，接着指定该服务使用的镜像。\r\n   \r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       # The app service definition\r\n     mysql:\r\n       image: mysql:5.7\r\n   ```\r\n2. 接着定义 `named volume` 的映射关系。当我们使用 `docker run` 运行容器时，Docker 会自动创 `named volume`。但是，使用 Compose 运行时不会自动创建，所以我们需要在配置文件的顶层使用 `volumes` 属性定义 `named volume`，然后在 MySQL 服务下的 `volumes` 指定它的实际挂载点。\r\n   \r\n   > 备注：这两个 `volumes` 出现的位置不一样。第一个是在 compose 文件的顶层，另外一个是在 MySQL 这个服务之下。\r\n   \r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n     # The app service definition\r\n   mysql:\r\n     image: mysql:5.7\r\n   volumes:\r\n     - todo-mysql-data:/var/lib/mysql\r\n   \r\n   volumes:\r\n   todo-mysql-data:\r\n   ```\r\n3. 最后，指定启动 MySQL 服务需要的环境变量\r\n   \r\n   ```\r\n   version: \"3.7\"\r\n   \r\n   services:\r\n     todo-app:\r\n       # The app service definition\r\n     mysql:\r\n       image: mysql:5.7\r\n       volumes:\r\n         - todo-mysql-data:/var/lib/mysql\r\n       environment: \r\n         MYSQL_ROOT_PASSWORD: secret\r\n         MYSQL_DATABASE: todos\r\n   \r\n   volumes:\r\n     todo-mysql-data:\r\n   ```\r\n\r\n此时，完整的 `docker-compose.yml` 看起来像这样：\r\n\r\n```\r\nversion: \"3.7\"\r\n\r\nservices:\r\n  todo-app:\r\n    image: node:12-alpine\r\n    command: sh -c \"yarn install && yarn run dev\"\r\n    ports:\r\n      - 3000:3000\r\n    working_dir: /app\r\n    volumes:\r\n      - ./:/app\r\n    environment:\r\n      MYSQL_HOST: MySQL\r\n      MYSQL_USER: root\r\n      MYSQL_PASSWORD: secret\r\n      MYSQL_DB: todos\r\n\r\n  mysql:\r\n    image: mysql:5.7\r\n    volumes:\r\n      - todo-mysql-data:/var/lib/mysql\r\n    environment: \r\n      MYSQL_ROOT_PASSWORD: secret\r\n      MYSQL_DATABASE: todos\r\n\r\nvolumes:\r\n  todo-mysql-data:\r\n```\r\n\r\n## 启动我们的完整应用\r\n\r\n现在我们已经有了 `docker-compose.yml` 文件，就可以启动它了！\r\n\r\n1. 确保之前通过命令行启动的应用和 MySQL 容器已经停止并删除了。如何还运行着，可以通过 Docker Desktop 或者使用 docker ps 配合 docker rm -f <container-ids> 删除它们。\r\n2. 使用 `docker-compose up` 命令启动应用程序栈（`todo-app` + `mysql`）。添加 `-d` 标志可以让它们保持在后台运行。\r\n   \r\n   ```\r\n   docker-compose up -d\r\n   ```\r\n   \r\n   运行此命令之后，应看到如下输出：\r\n   \r\n   ```\r\n   Creating network \"app_default\" with the default driver\r\n   Creating volume \"app_todo-mysql-data\" with default driver\r\n   Creating app_todo-app_1   ... done\r\n   Creating app_mysql_1 ... done\r\n   ```\r\n   \r\n   你应该已经注意到了，`volume` 和 `network` 都已经已创建成功。默认情况下，Docker Compose 会自动为应用程序栈自动创建一个网络，这就是为什么我们没有在 compose 文件中显式定义网络的原因。\r\n3. 让我们使用 `docker-compose logs -f` 命令查看日志。每个服务的日志汇总统一输出在这里。`-f` 标志用于实时输出日志。\r\n   \r\n   如果要查看特定服务的日志，可以将服务名称添加到 logs 命令的末尾（例如 `docker-compose logs -f mysql`）。\r\n4. 至此，只用了一个命令就可以启动我们应用程序需要的所有服务了。\r\n\r\n## 在 Docker Dashboard 中查看我们的应用程序栈\r\n\r\n如果现在查看 Docker Dashboard，将会看到有一个名为 `app` 的组，将所有使用到的容器组在一起了。默认情况下，项目名称是 `docker-compose.yml` 文件所在目录的名称。\r\n\r\n![Docker Dashboard with app project](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/6rTMo1628305678_Docker_Dashboard_with_app_project1617270116.png)\r\n\r\n如果点击 `app` 这个分组，将会看到我们在 `docker-compose.yml` 文件中定义的两个容器。名称也更具描述性，因为它们遵循 `< 项目名称 >_< 服务名称 >_< 副本编号 >` 的格式。因此，可以很方便的查看哪个容器是我们的 `todo` 服务以及哪个容器是 MySQL 数据库服务。\r\n\r\n![Docker Dashboard with app project expanded](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/Zdsmk1628305678_Docker_Dashboard_with_app_project_expanded1617270117.png)\r\n\r\n## 删除所有容器\r\n\r\n如果要将它们全部删除，只需运行 `docker-compose down` 或在 Docker Dashboard 上点击垃圾桶图标即可。同时也会删除自动创建的网络。\r\n\r\n删除 Volumes\r\n默认情况下，运行 `docker-compose down` 命令，不会自动删除 `docker-compose.yml` 文件中定义的 `named volumes`。如果要删除 volumes，只需添加 `--volumes` 标志即可。\r\n\r\n## 回顾\r\n\r\n在本节中，我们学习了如何利用 Docker Compose 帮助我们极大简化多服务应用程序的定义和分享。我们把之前使用的命令转换为对应的 compose 格式，写入新创建的 `docker-compose.yml` 文件中。然后，就可以只使用一条命令启动或者删除所有服务了。\r\n\r\n下一节让我们更进一步，介绍一些构建镜像的最佳实践。\r\n\r\n> 原始资料：[Using Docker Compose](https://docs.docker.com/get-started/08_using_compose/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 3, 1, now(), NULL, NULL),
	('构建 Docker 镜像的最佳实践', NULL, 'docker-image-building-best-practices__doc', '## 安全扫描\r\n\r\n镜像构建完成之后，最好使用 `docker scan` 命令对其进行扫描以查找安全漏洞。Docker 与 [Snyk](http://snyk.io/) 合作提供漏洞扫描服务。\r\n\r\n例如，要扫描我们自己创建的 `todo-app` 镜像，只需执行以下命令：\r\n\r\n```\r\ndocker scan todo-app\r\n```\r\n\r\n扫描命令使用了一个不断更新的漏洞数据库，如果没有发现漏洞，类似如下输出：\r\n\r\n```\r\n➜  ~ docker scan todo-app\r\nDocker Scan relies upon access to Snyk, a third party provider, do you consent to proceed using Snyk? (y/N)\r\ny\r\n\r\nTesting todo-app...\r\n...\r\n\r\n✓ Tested 16 dependencies for known vulnerabilities, no vulnerable paths found.\r\n\r\nFor more free scans that keep your images secure, sign up to Snyk at https://dockr.ly/3ePqVcp\r\n\r\n➜  ~\r\n```\r\n\r\n如果发现了漏洞，类似如下输出：\r\n\r\n```\r\n✗ Low severity vulnerability found in freetype/freetype\r\n  Description: CVE-2020-15999\r\n  Info: https://snyk.io/vuln/SNYK-ALPINE310-FREETYPE-1019641\r\n  Introduced through: freetype/freetype@2.10.0-r0, gd/libgd@2.2.5-r2\r\n  From: freetype/freetype@2.10.0-r0\r\n  From: gd/libgd@2.2.5-r2 > freetype/freetype@2.10.0-r0\r\n  Fixed in: 2.10.0-r1\r\n\r\n✗ Medium severity vulnerability found in libxml2/libxml2\r\n  Description: Out-of-bounds Read\r\n  Info: https://snyk.io/vuln/SNYK-ALPINE310-LIBXML2-674791\r\n  Introduced through: libxml2/libxml2@2.9.9-r3, libxslt/libxslt@1.1.33-r3, nginx-module-xslt/nginx-module-xslt@1.17.9-r1\r\n  From: libxml2/libxml2@2.9.9-r3\r\n  From: libxslt/libxslt@1.1.33-r3 > libxml2/libxml2@2.9.9-r3\r\n  From: nginx-module-xslt/nginx-module-xslt@1.17.9-r1 > libxml2/libxml2@2.9.9-r3\r\n  Fixed in: 2.9.9-r4\r\n```\r\n\r\n列出了漏洞类型、了解更多信息的 URL 等等，最重要的是哪个版本修复了该漏洞，以便我们及时更新到安全的版本。\r\n\r\n更多关于漏洞扫描的信息可以查看 [docker scan documentation](https://docs.docker.com/engine/scan/)\r\n\r\n除了在命令行上扫描新生成的镜像外，还可以 [配置 Docker Hub](https://docs.docker.com/docker-hub/vulnerability-scanning/) 来自动扫描所有新推送的镜像，然后在 Docker Hub 和 Docker Desktop 中查看安全扫描结果。类似下图的显示：\r\n\r\n![Hub vulnerability scanning](https://bianxuebianzuo.oss-cn-shenzhen.aliyuncs.com/uploads/photos/1/2021/08/07/zoKGp1628305754_Hub_vulnerability_scanning1617270166.png)\r\n\r\n## 镜像分层\r\n\r\n1. 可以通过 `docker image history` 命令查看镜像的创建历史，镜像中每个图层的都执行了哪些命令。\r\n\r\n```bash\r\ndocker image history todo-app\r\n```\r\n\r\n你应该能看到类似如下的输出：\r\n\r\n```plaintext\r\nIMAGE               CREATED             CREATED BY                                      SIZE                COMMENT\r\na78a40cbf866        18 seconds ago      /bin/sh -c #(nop)  CMD [\"node\" \"src/index.j…    0B                  \r\nf1d1808565d6        19 seconds ago      /bin/sh -c yarn install --production            85.4MB              \r\na2c054d14948        36 seconds ago      /bin/sh -c #(nop) COPY dir:5dc710ad87c789593…   198kB               \r\n9577ae713121        37 seconds ago      /bin/sh -c #(nop) WORKDIR /app                  0B                  \r\nb95baba1cfdb        13 days ago         /bin/sh -c #(nop)  CMD [\"node\"]                 0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop)  ENTRYPOINT [\"docker-entry…   0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop) COPY file:238737301d473041…   116B                \r\n<missing>           13 days ago         /bin/sh -c apk add --no-cache --virtual .bui…   5.35MB              \r\n<missing>           13 days ago         /bin/sh -c #(nop)  ENV YARN_VERSION=1.21.1      0B                  \r\n<missing>           13 days ago         /bin/sh -c addgroup -g 1000 node     && addu…   74.3MB              \r\n<missing>           13 days ago         /bin/sh -c #(nop)  ENV NODE_VERSION=12.14.1     0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop)  CMD [\"/bin/sh\"]              0B                  \r\n<missing>           13 days ago         /bin/sh -c #(nop) ADD file:e69d441d729412d24…   5.59MB\r\n```\r\n\r\n每一行代表镜像中的一层，默认最新的一层显示在最上方。使用这条命令，还可以快速查看镜像中每一层的大小。\r\n2. 命令默认会对较长的内容进行自动省略处理以保持整洁的输出。如果想查看完整的内容，可以添加 `--no-trunc` 标志。\r\n\r\n```bash\r\ndocker image history --no-trunc todo-app\r\n```\r\n\r\n## 层缓存\r\n\r\n现在我们已经知道了镜像是分层的，再记住一点：`一旦某一层有更新，该层以及它的所有下层也必须重新构建`。利用好这一特性将有助于减少构建镜像所需花费的时间。\r\n\r\n回顾之前创建的 Dockerfile 文件内容\r\n\r\n```dockerfile\r\nFROM node:12-alpine\r\nWORKDIR /app\r\nCOPY . .\r\nRUN yarn install --production\r\nCMD [\"node\", \"src/index.js\"]\r\n```\r\n\r\n对照上一步执行 `docker image history` 的输出结果，会发现 Dockerfile 文中的每一行命令都对应到镜像中的一个层。你应该还记得，在之前的章节当我们只对源码做一小点文本的修改，但是在更新镜像时，同样必须重新执行每个层的命令，比如重新之下 yarn install 安装依赖等等。显然每次都执行 yarn 命令安装依赖是多余的，有没有解决方法？\r\n\r\n要解决这个问题，需要对 Dockerfile 文件进行修改，调整几条命令的执行顺序就可以利用镜像的缓存功能避免执行多余的 yarn install 操作了。对于基于 Node 的应用程序，这些依赖项是在 package.json 文件中定义的。因此，我们只需先把该文件复杂到容器，再安装依赖，然后复制剩下的内容。这样调整之后，只有当 `package.json` 文件有变动时才会执行 yarn install 操作。\r\n\r\n1. 如上所述调整我们的 Dockerfile 文件：增加一行 `COPY package.json yarn.lock ./`；同时将 `COPY . .` 移到 `RUN yarn install --production` 之后\r\n   \r\n   ```dockerfile hl_lines=\"3 4 5\"\r\n   FROM node:12-alpine\r\n   WORKDIR /app\r\n   COPY package.json yarn.lock ./\r\n   RUN yarn install --production\r\n   COPY . .\r\n   CMD [\"node\", \"src/index.js\"]\r\n   ```\r\n2. 在与 Dockerfile 相同的目录下新创建一个名为 `.dockerignore` 的文件，内容如下:\r\n   \r\n   ```ignore\r\n   node_modules\r\n   ```\r\n   \r\n   `.dockerignore` 文件可以告诉 Docker 在构建镜像时忽略某些文件或文件夹，由于 `node_modules` 文件夹是在执行 yarn install 命令时自动生成的，因此它不需要作为镜像的固有内容，忽略它才是对的，而且还可以减少镜像的大小。点击 [这里](https://docs.docker.com/engine/reference/builder/#dockerignore-file) 查看更多关于 `.dockerignore` 的信息。\r\n3. 再次使用 `docker build -t todo-app .` 命令构建新镜像\r\n   \r\n   会看到类似如下输出：\r\n   \r\n   ```plaintext\r\n   Sending build context to Docker daemon  219.1kB\r\n   Step 1/6 : FROM node:12-alpine\r\n   ---> b0dc3a5e5e9e\r\n   Step 2/6 : WORKDIR /app\r\n   ---> Using cache\r\n   ---> 9577ae713121\r\n   Step 3/6 : COPY package.json yarn.lock ./\r\n   ---> bd5306f49fc8\r\n   Step 4/6 : RUN yarn install --production\r\n   ---> Running in d53a06c9e4c2\r\n   yarn install v1.17.3\r\n   [1/4] Resolving packages...\r\n   [2/4] Fetching packages...\r\n   info fsevents@1.2.9: The platform \"linux\" is incompatible with this module.\r\n   info \"fsevents@1.2.9\" is an optional dependency and failed compatibility check. Excluding it from installation.\r\n   [3/4] Linking dependencies...\r\n   [4/4] Building fresh packages...\r\n   Done in 10.89s.\r\n   Removing intermediate container d53a06c9e4c2\r\n   ---> 4e68fbc2d704\r\n   Step 5/6 : COPY . .\r\n   ---> a239a11f68d8\r\n   Step 6/6 : CMD [\"node\", \"src/index.js\"]\r\n   ---> Running in 49999f68df8f\r\n   Removing intermediate container 49999f68df8f\r\n   ---> e709c03bc597\r\n   Successfully built e709c03bc597\r\n   Successfully tagged todo-app:latest\r\n   ```\r\n   \r\n   这一次你会看到所有层都已重建，因为我们更改了 Dockerfile 文件。\r\n4. 现在我们要再一次修改源码，将 `src/static/index.html` 文件第 11 行 `<title>` 标签的内容改为 \"The Awesome Todo App\"\r\n5. 再次使用 `docker build -t todo-app .` 命令构建镜像。这次的输出应该看起来有些不同了：\r\n   \r\n   ```plaintext hl_lines=\"5 8 11\"\r\n   Sending build context to Docker daemon  219.1kB\r\n   Step 1/6 : FROM node:12-alpine\r\n   ---> b0dc3a5e5e9e\r\n   Step 2/6 : WORKDIR /app\r\n   ---> Using cache\r\n   ---> 9577ae713121\r\n   Step 3/6 : COPY package.json yarn.lock ./\r\n   ---> Using cache\r\n   ---> bd5306f49fc8\r\n   Step 4/6 : RUN yarn install --production\r\n   ---> Using cache\r\n   ---> 4e68fbc2d704\r\n   Step 5/6 : COPY . .\r\n   ---> cccde25a3d9a\r\n   Step 6/6 : CMD [\"node\", \"src/index.js\"]\r\n   ---> Running in 2be75662c150\r\n   Removing intermediate container 2be75662c150\r\n   ---> 458e5c6f080c\r\n   Successfully built 458e5c6f080c\r\n   Successfully tagged todo-app:latest\r\n   ```\r\n   \r\n   这次应该能明显的感觉到构建速度快了很多！因为有好几个层使用了缓存。\r\n\r\n## 多阶段构建\r\n\r\n虽然在本教程中不会做太多的介绍，但是多阶段构建非常有用。\r\n\r\n### Maven/Tomcat 示例\r\n\r\n在构建基于 Java 的应用程序时，需要使用 JDK 将 Java 源代码编译为 Java 字节码。然而， 在生产环境中不需要完整的 JDK，只需 JRE 即可。另外，你可能正在使用 Maven 或 Gradle 之类的工具来帮助构建应用程序，在最终的镜像中也不需要这类开发阶段使用到的工具。使用多阶段构建可以解决这些问题。\r\n\r\n```dockerfile\r\nFROM maven AS build\r\nWORKDIR /app\r\nCOPY . .\r\nRUN mvn package\r\n\r\nFROM Tomcat\r\nCOPY --from=build /app/target/file.war /usr/local/tomcat/webapps\r\n```\r\n\r\n在此示例中，我们使用一个称为 `build` 的阶段，通过 Maven 构建 Java 应用程序。第二个阶段从 `FROM tomcat` 开始，我们从 `build` 这个第一阶段的结果中复制文件。默认情况下最终的镜像内容由最后一个阶段创建（可以使用 `--target` 标志自己指定）。\r\n\r\n### React 示例\r\n\r\n在构建 React 应用程序时，我们需要一个 Node 环境来编译 JS 代码、SASS 样式、以及更多的静态 HTML、JS 和 CSS。如果我们不需要服务器端渲染，则在生产环境中我们甚至都不需要 Node 环境，只需将编译好之后的静态资源放到镜像中即可，如下所示：\r\n\r\n```dockerfile\r\nFROM node:12 AS build\r\nWORKDIR /app\r\nCOPY package* yarn.lock ./\r\nRUN yarn install\r\nCOPY public ./public\r\nCOPY src ./src\r\nRUN yarn run build\r\n\r\nFROM nginx:alpine\r\nCOPY --from=build /app/build /usr/share/nginx/html\r\n```\r\n\r\n## 回顾\r\n\r\n在本节中，先通过对我们的镜像进行安全扫描，以确保我们正在运行和分享的镜像是安全的。然后了解了一些镜像的结构及特点，对我们应用程序的 Dockerfile 文件稍作修改，以便更快地构建镜像。最后通过多阶段构建，将开发环境和生产环境需要的依赖区分开，不止可以减少镜像的大小，还能提高容器的安全性。\r\n\r\n> 原始资料：[Image building tips](https://docs.docker.com/get-started/09_image_best/)\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 3, 1, now(), NULL, NULL),
	('Docker 基础知识回顾', NULL, 'docker-intro-recap__doc', '经过前面几个章节的学习，相信对 Docker 已经不再陌生了：\r\n\r\n- 学习了 Docker 的基本操作\r\n  * 通过 Docker 提供的命令行工具操作 Docker\r\n  * 通过 Docker Desktop 可视化界面操作 Docker\r\n- 学习了如何使用别人的镜像来启动容器\r\n- 学习了如何构建并分享自己的镜像\r\n  * 使用 Volume 保存数据 (**named volume** 和 **bind mounts**)\r\n  * 借助 Network 与其他容器沟通\r\n- 还学习了不少进阶知识\r\n  * 多容器应用 Multi-Container Apps\r\n  * 使用 Docker Compose\r\n  * 构建镜像的最佳实践 （安全扫描、镜像分层、层缓存、多阶段构建 ......)\r\n\r\nDocker 还有很多更高级的功能，它本身也还在不断发展中。在后续的学习过程中，可以留意 [Docker 官网](https://www.docker.com/) 第一时间了解 Docker 最新动态。\r\n\r\n', NULL, NULL, 0, '', NULL, 0, 0, 0, 0, NULL, 4, 1, now(), NULL, NULL);